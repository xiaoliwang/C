# C（数据结构）
---

## 数据结构和算法的基础概念
数据的逻辑结构：

- 集合
- 线性
- 树形
- 图形

数据元素的存储结构：

- 顺序存储
- 链式存储

算法三要素：

- 有穷性
- 确定性
- 可行性

渐进增长：
> 函数的渐进增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有n>N，f(n)总是比g(n)大，我们说f(n)的增长渐进快于g(n)。

时间复杂度：
> T(n) = O(f(n))
> O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
> 基本不考虑O(n^3)以上的算法
> **时间复杂度一般都是值最坏复杂度** 

算法的空间复杂图：
> S(n) = O(f(n))

## 线性结构

### 线性表(list)

- 零个或多个数据元素的优先序列。  
- 若将线性表记为(a1, ..., ai-1, ai, ai+1, ..., an),则表中ai-1领先于ai,ai领先于ai+1,称ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。
- 线性表元素的个数为n(n为自然数)定义为线性表的长度，当n=0时，称为空表。

Operation:

- InitList(*L)
- ListEmpty(L)
- ClearList(*L)
- GetElem(L, i, *e)
- LocateElem(L, e)
- ListInsert(*L, i, e)
- ListDelete(*L, i, *e)
- ListLength(L)

**我们通常把具有存取时间性能为O(1)的存储结构称为随机存储结构**

线性表顺序存储结构  
优点：

- 无需为存储逻辑有新的存储开销
- 可以快速地存取表中任意位置

缺点：

- 插入和删除时，开销较大
- 容量变大时，不易确定存储容量
- 造成存储空间碎片

**若线性表需要频繁查找，很少插入和删除，宜采用顺序存储结构。反之采用单链表结构**
**用数组描述的链表叫做静态链表**

### 栈（stack）

- 是限定仅在表尾进行插入和删除操作的线性表
- 我们把允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom),不含任何数据元素的栈称为空栈。栈又称为后进先出(Last In First Out)的线性表，简称LIFO结构
- 栈的插入操作，叫做进栈，也称压栈、入栈
- 栈的删除操作，叫做出栈，也有的叫做弹栈

> 如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些。

- 一种不需要括号的后缀表达法，我们也把它称为逆波兰(Reverse Polish Notation, RPN)
- 标准四则运算表达式叫做中缀表达式

### 队列（queue）
- 是只允许在一端进行插入操作，而在另一端进行删除操作的线性表
- 队列是一种先进先出(First In First Out)的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。
- 我们把队列的这种头尾相接的顺序存储结构称为循环队列
- 队列的链式存储结构，即线性表的单链表并只能尾进头出。简称为链队列

### 串（string）
- 串(string)是由零个或多个字符组成的有限序列，有名叫字符串。
- 零个字符的串称为空串(null string),可以使用""表示。
- 串中任意个数的连续字符组成的子序列称为该串的子串。


*KPM*算法
$$
next(j)=\begin{cases}
0&\text{当j=1时}\\
\max\{k | 1<k<j,且`p_{1}..._{k-1}` = `p_{j-k+1} ... P_{j-1}`\}当此集合不空时\\
1&\text{其它情况}
\end{cases}
$$

### 树（Tree）
定义：
> 树(Tree)是n(n>=0)个结点的有限集。n=0时称为空树。在任意一棵非空树中:
1. 有且仅有一个特定的称为根(Root)的结点。
2. 当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1、T2、...、Tm，其中每一个集合本身又是一个树，并且称为根的子树(subTree)

结点分类：
1. 结点拥有的子树数称为结点的度(Degree)。度为0的结点称为叶结点(Leaf)或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。
2. 结点的子树的根称为该结点的孩子(Child)，相应地，该结点称为孩子的双亲(Parent)
3. 同一个双亲的孩子之间互称兄弟(sibling)。
4. 结点的祖先是从根到该结点所经分支上的所有结点。
5. 以某结点为根的子树中的任一结点都称为该结点的子孙。

树的其它相关概念：
1. 结点的层次(Level)从根开始定义起，根为第一层，根的孩子为第二层。树中结点的最大层次称为树的深度(Depth)或高度。
2. 如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序数，否则为无序数。
3. 森林(Forset)是m(m>=0)课互不相交的树的集合。

#### 二叉树（Binary Tree）
定义：
> 二叉树是n(n>=0)个结点的有限集合，该集合或者为空集(称为空二叉树),或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。

特点：

1. 每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。
2. 左子树和右子树是有顺序的，次序不能任意颠倒。
3. 即使树种某结点只有一棵子树，也要区分它的左子树还是右子树。

特殊二叉树：

1. 斜树: 所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜数。
2. 满二叉树: 在一棵二叉树中，如果所有分支结点都存在左子树和右子树。并且所有叶子都在同一层上，这样的二叉树称为满二叉树。
1. 完全二叉树: 对一棵具有n个结点的二叉树按层序编号，如果编号为i（1<=i<=n）的结点与同样深度的满二叉树中标号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。特点：
- 叶子结点只能出现在最下两层。
- 最下层的叶子一定集中在左部连续位置。
- 倒数两层，若有叶子结点，一定都在右部连续位置。
- 如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况
- 同样结点数的二叉树，完全二叉树的深度最小

二叉树性质：

1. 在二叉树的第i层上之多有$2^{i-1}$个结点。
2. 深度为k的二叉树至多有$2^k-1$个结点。
> 证明:
满二叉树结点数为$$1+2+\cdots+2^{k-1} = 2^k-1$$ 

3. 对任何一棵二叉树T,如果其终端结点数为$n_0$,度为2的结点数为$n_2$,则$n_0=n_2+1$。
> 证明: 
$\because n-1 = 2n_2 + n_1(边的数量为n-1)\\
\because n = n_1 + n_2 + n_0\\
\therefore n_0 = n_2 + 1$

4. 具有n个结点的完全二叉树的深度为[$log_2n$]＋1([x]表示不大于x的最大整数)
> 证明:
$\because$因为深度为k的满二叉树结点为$2^k-1$
$\therefore$n个结点的满二叉树则深度为$log_2(n+1)$
如果完全二叉树和满二叉树度数相同，那么它的结点数一定少于等于同样度数的满二叉树，且一定多于$2^{k-1}-1$。即$2^{k-1}-1<n\leq2^k-1$。由于n是整数，所以$2^{k-1}{\leq}n<2^K$。$\because$k也是整数。
$\because$深度为[$log_2n$]＋1

5. 如果对一棵有n个结点的完全二叉树（其深度为$[log_2n]+1$的结点按层次编号，对任一结点i($1{\leq}i{\leq}n$)有）
 1. 如果i=1,则结点i是root，如果i>1,则其双亲是结点[i/2]
 2. 如果2i>n,则结点i为leaves；否则其做孩子是结点2i。
 3. 如果2i+1>n,则结点i无右孩子；否则其右孩子是结点2i+1。
 
二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅访问一次。

1. 前序遍历
> 首先访问根结点然后遍历左子树，最后遍历右子树。在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树。(root, left, right)
2. 中序遍历
> 先遍历左子树，然后访问根结点，最后遍历右子树。在遍历左、右子树时，仍然先遍历左子树，再访问根结点，最后遍历右子树。(left, root, right)
3. 后序遍历
> 首先遍历左子树，然后遍历右子树，最后访问根结点，在遍历左、右子树时，仍然先遍历左子树，然后遍历右子树，最后遍历根结点。(left, right, root)
4. 层序遍历
> 从树的第一层开始访问，从上向下逐层遍历，在同一层中，按从左到有的顺序对结点逐个访问。

有n个结点的二叉链表，一共有2n个指针域。而二叉树一共有n-1条分支。所以存在n+1个空指针域。我们给这些空指针域加上前驱和后继，称为线索。加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树。

树与森林的遍历：

1. 先根遍历
> 先访问树的根结点，然后依次对每棵子树进行先根访问。（树的前序，二叉树的前序）

2. 后根遍历
> 依次对每棵树进行后根访问，在访问树的根结点。（树的后续，二叉树的中序）

哈夫曼树（Huffman tree）
从树中一个结点到另一个结点之间的分支构成两个结点之间的**路径**，路径上的分支数目称作**路径长度**。树的路径长度就是从树根到每一结点的路径长度之和。树的带权路径长度为树中所有叶子结点的带权路径（WPL）之和，其中WPL最小的二叉树称为**哈夫曼树**（最优二叉树）

### 图 （Graph）